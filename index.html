<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>SE DEMO</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
:root {
    /* Ocean-inspired color palette */
    --main-green: #4B675C;     
    --ocean-blue: #326291;     
    --light-blue: #9EBAD3;    
    --turquoise: #68A5A8;     
    --ballad-blue: #7CAAC2;    
    
    /* Neutral colors */
    --white: #FFFFFF;
    --light-gray: #F5F7F9;
    --medium-gray: #E0E6EB;
    --dark-gray: #4A5568;
    --black: #2D3748;
    
    /* Status colors */
    --success-bg: #d4edda;
    --success-text: #155724;
    --success-border: #c3e6cb;
    --error-bg: #f8d7da;
    --error-text: #721c24;
    --error-border: #f5c6cb;
    --danger: #E53E3E;
    --danger-dark: #C53030;
}

body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
.marker-btn {
    display: block;
    width: 28px;
    height: 28px;
    background-size: contain;
    cursor: pointer;
    background-repeat: no-repeat;
}


.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(45, 55, 72, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

.modal-overlay.active {
    opacity: 1;
    visibility: visible;
}

.modal {
    background: rgba(255, 255, 255, 0.8); 
    width: 90%;
    max-width: 400px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(75, 103, 92, 0.15);
    transform: translateY(20px);
    transition: transform 0.3s ease;
}

.modal-overlay.active .modal {
    transform: translateY(0);
}

.modal-header {
    background-color: var(--main-green);
    padding: 16px 20px;
    border-bottom: 1px solid var(--medium-gray);
}

.modal-header h3 {
    margin: 0;
    color: var(--white);
    font-size: 18px;
    font-weight: 600;
}

.modal-content {
    padding: 20px;
}

.icon-selection {
    display: flex;
    justify-content: space-around;
    margin-bottom: 20px;
}

.icon-option {
    text-align: center;
    cursor: pointer;
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.icon-option.selected {
    background-color: var(--light-gray);
    border: 1px solid var(--main-green);
}

.icon-option:hover:not(.selected) {
    background-color: var(--light-gray);
}

.icon-option img {
    width: 40px;
    height: 40px;
    object-fit: contain;
}

.icon-option p {
    margin: 5px 0 0;
    font-size: 14px;
    color: var(--dark-gray);
}

.form-group {
    margin-bottom: 16px;
}

.form-group label {
    display: block;
    margin-bottom: 6px;
    font-weight: 500;
    color: var(--dark-gray);
    font-size: 14px;
}

.form-group input, .form-group select {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--medium-gray);
    border-radius: 8px;
    font-size: 14px;
    transition: border-color 0.2s;
    box-sizing: border-box;
}

.form-group input:focus, .form-group select:focus {
    border-color: var(--main-green);
    outline: none;
    box-shadow: 0 0 0 3px rgba(75, 103, 92, 0.1);
}

.modal-footer {
    padding: 16px 20px;
    border-top: 1px solid var(--medium-gray);
    display: flex;
    justify-content: flex-end;
}

button {
    padding: 10px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}

button:active {
    transform: translateY(1px);
}

.save-btn {
    background-color: var(--main-green);
    color: var(--white);
    border: none;
    margin-left: 10px;
}

.save-btn:hover {
    background-color: var(--ocean-blue);
}

.save-btn:disabled {
    background-color: var(--light-blue);
    cursor: not-allowed;
}

.cancel-btn {
    background-color: var(--light-gray);
    color: var(--dark-gray);
    border: 1px solid var(--medium-gray);
}

.cancel-btn:hover {
    background-color: var(--medium-gray);
}

.remove-btn {
    background-color: var(--danger);
    color: var(--white);
    border: none;
    margin-left: 10px;
}

.remove-btn:hover {
    background-color: var(--danger-dark);
}


.mapboxgl-popup-content {
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(75, 103, 92, 0.15);
}

.control-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 1;
    background-color: var(--white);
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(75, 103, 92, 0.15);
    padding: 12px;
    width: 220px;
    display: none;
}

.load-data-btn {
    width: 100%;
    padding: 10px 16px;
    background-color: var(--main-green);
    color: var(--white);
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    margin-bottom: 10px;
}

.load-data-btn:hover {
    background-color: var(--ocean-blue);
}

.load-data-btn:disabled {
    background-color: var(--light-blue);
    cursor: not-allowed;
}

.status-indicator {
    font-size: 12px;
    margin-top: 5px;
    padding: 6px 10px;
    border-radius: 6px;
    text-align: center;
    display: none;
}

.status-indicator.success {
    display: block;
    background-color: var(--success-bg);
    color: var(--success-text);
    border: 1px solid var(--success-border);
}

.status-indicator.error {
    display: block;
    background-color: var(--error-bg);
    color: var(--error-text);
    border: 1px solid var(--error-border);
}

.current-sheet-id {
    font-size: 12px;
    color: var(--dark-gray);
    margin-top: 5px;
    word-break: break-all;
}

.icon-preview {
    display: flex;
    justify-content: space-between;
    margin-top: 10px;
    padding: 8px;
    background-color: var(--light-gray);
    border-radius: 6px;
}

.icon-preview-item {
    text-align: center;
    flex: 1;
}

.icon-preview-item img {
    width: 30px;
    height: 30px;
    object-fit: contain;
}

.icon-preview-item span {
    display: block;
    font-size: 10px;
    color: var(--dark-gray);
    margin-top: 2px;
}

@keyframes heartbeat {
    0% {
        transform: scale(1) translate(-50%, -50%);
    }
    25% {
        transform: scale(1.1) translate(-45%, -45%);
    }
    50% {
        transform: scale(1) translate(-50%, -50%);
    }
    75% {
        transform: scale(1.1) translate(-45%, -45%);
    }
    100% {
        transform: scale(1) translate(-50%, -50%);
    }
}

@keyframes pulse {
    0% {
        filter: brightness(1) drop-shadow(0 0 0px rgba(255, 255, 255, 0.7));
    }
    50% {
        filter: brightness(1.2) drop-shadow(0 0 5px rgba(255, 255, 255, 0.9));
    }
    100% {
        filter: brightness(1) drop-shadow(0 0 0px rgba(255, 255, 255, 0.7));
    }
}

.marker-btn.purchased {
    animation: pulse 2s infinite ease-in-out;
    transform-origin: center center;
}

.mapboxgl-marker {
    position: absolute;
    top: 0;
    left: 0;
    will-change: transform;
}

.product-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(33, 43, 54, 0.85);
    padding: 8px 10px; 
    display: flex;
    justify-content: flex-start; 
    align-items: center;
    flex-wrap: nowrap; 
    z-index: 100;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(5px);
    overflow-x: auto; 
    scrollbar-width: thin; 
    -ms-overflow-style: none; 
}

/* Hide scrollbar for Chrome, Safari and Opera */
.product-bar::-webkit-scrollbar {
    height: 4px;
}

.product-bar::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
}

.product-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 90px; 
    max-width: 120px; 
    flex: 0 0 auto; 
}

.product-icon {
    width: 32px; 
    height: 32px;
    margin-bottom: 3px; 
}

.product-name {
    color: var(--white);
    font-size: 11px; 
    margin-bottom: 3px; 
    text-align: center;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}

.progress-container {
    width: 100%;
    background-color: var(--medium-gray);
    height: 8px; 
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.progress-value {
    position: absolute;
    right: 0;
    top: 0;
    background-color: rgba(255, 255, 255, 0.9);
    color: var(--black);
    font-size: 9px; 
    padding: 0 3px;
    border-radius: 2px;
    transform: translate(calc(100% + 3px), -1px);
}

.quantity-info {
    color: var(--white);
    font-size: 10px; 
    text-align: center;
    margin-top: 2px; 
    opacity: 0.9;
}


.progress-bar {
    height: 100%;
    background-color: var(--main-green);
    border-radius: 5px;
    transition: width 0.5s ease-in-out;
}

.progress-bar.low {
    background-color: var(--success-text);
}

.progress-bar.medium {
    background-color: var(--success-text);
}

.progress-bar.high {
    background-color: var(--success-text);
}


@media (max-width: 768px) {
    .product-bar {
        padding: 6px;
        justify-content: flex-start;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; 
    }
    
    .product-item {
        min-width: 75px;
    }
    
    .product-icon {
        width: 28px;
        height: 28px;
    }
}

.loading-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999;
    background-color: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(3px);
}

.loading-indicator {
    background-color: white;
    border-radius: 12px;
    padding: 20px 30px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    text-align: center;
    max-width: 300px;
}

.loading-indicator h3 {
    margin: 0 0 15px 0;
    color: var(--dark-gray);
}

.spinner {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 4px solid rgba(75, 103, 92, 0.3);
    border-radius: 50%;
    border-top-color: var(--main-green);
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 15px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}


.marker-container {
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
}


.marker-progress-container {
    width: 40px;
    background-color: var(--medium-gray);
    height: 6px; 
    border-radius: 5px;
    margin-top: 5px; 
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.marker-progress-bar {
    height: 100%;
    background-color: var(--main-green); 
    border-radius: 5px;
    transition: width 0.5s ease-in-out;
}

.marker-quantity-info {
    color: white;
    font-size: 10px;
    text-align: center;
    margin-top: 3px;
    background-color: rgba(33, 43, 54, 0.85);
    padding: 2px 4px;
    border-radius: 3px;
    white-space: nowrap;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}


.marker-progress-bar.low {
    background-color: var(--success-text);
}

.marker-progress-bar.medium {
    background-color: var(--success-text);
}

.marker-progress-bar.high {
    background-color: var(--success-text);
}
    </style>
</head>

<body>
    <div id="map"></div>
    
    <div class="control-panel">
        <button class="load-data-btn" id="loadDataBtn">Refresh Data</button>
        <div id="statusIndicator" class="status-indicator"></div>
        <div id="currentSheetId" class="current-sheet-id"></div>
    </div>
    
    <div class="modal-overlay" id="markerModal">
        <div class="modal">
            <div class="modal-header">
                <h3 id="modalTitle">Add New Marker</h3>
            </div>
            <div class="modal-content" id="modalContent"></div>
            <div class="modal-footer">
                <button class="cancel-btn" id="modalCancelBtn">Cancel</button>
                <button class="remove-btn" id="modalRemoveBtn" style="display: none;">Remove</button>
                <button class="save-btn" id="modalSaveBtn" disabled>Save</button>
            </div>
        </div>
    </div>

    <div class="product-bar" id="productBar">
        <!-- Product items will be added here dynamically -->
    </div>

    <div id="loadingContainer" class="loading-container">
        <div class="loading-indicator">
            <div class="spinner"></div>
            <div class="loading-text">Loading...</div>
        </div>
    </div>
    <script>
        // Initialize Mapbox
        mapboxgl.accessToken = 'pk.eyJ1Ijoic2hhcmVjcm9wIiwiYSI6ImNtMTh5ZzBxcDFiNzUya3NqYmdrMG4wcWYifQ.QwAneqqq6YPcd_QmOd5SQw';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/sharecrop/cm7xfhpps023601qo964wbsqs',
            center: [12.5674, 41.8719],
            zoom: 6,
            hash: true
        });

        // Global variables
        let categoriesData = []; // Store full category objects
        let categoryNames = []; // Store just the names for the dropdown
        let icons = {};
        const markers = [];
        let currentLatLng = null;
        let editingMarkerIndex = null;
        let sheetId = localStorage.getItem('googleSheetId') || '1BFp9tDHauIzg4r5_7rFuaCSxFZ9tkWJ8X06bDFnigt4';
        let uniqueProducts = {};

        // DOM elements
        const modalOverlay = document.getElementById('markerModal');
        const modalContent = document.getElementById('modalContent');
        const modalSaveBtn = document.getElementById('modalSaveBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalRemoveBtn = document.getElementById('modalRemoveBtn');
        const modalTitle = document.getElementById('modalTitle');
        const loadDataBtn = document.getElementById('loadDataBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const currentSheetId = document.getElementById('currentSheetId');
        const loadingContainer = document.getElementById('loadingContainer');
        const productBar = document.getElementById('productBar');

        // Fetch products data
        fetch('products.json')
            .then(response => response.json())
            .then(data => {
                categoriesData = data.categories; // Store the full data
                categoryNames = data.categories.map(cat => cat.name); // Extract names separately
                icons = data.categories.reduce((acc, category) => {
                    category.types.forEach(type => {
                        acc[type.iconType] = type.icon;
                    });
                    return acc;
                }, {});
                console.log('Loaded categories:', categoryNames);
                console.log('Loaded icons:', icons);
            })
            .catch(error => console.error('Error loading products.json:', error));

        // Update current sheet ID display
        function updateCurrentSheetIdDisplay() {
            if (sheetId) {
                currentSheetId.textContent = `Current Sheet ID: ${sheetId}`;
            } else {
                currentSheetId.textContent = 'No sheet ID saved';
            }
        }

        // Show status message
        function showStatus(message, isError = false) {
            statusIndicator.textContent = message;
            statusIndicator.className = 'status-indicator ' + (isError ? 'error' : 'success');
            
            setTimeout(() => {
                statusIndicator.className = 'status-indicator';
            }, 5000);
        }

        // Modal control functions
        function openModal() {
            modalOverlay.classList.add('active');
        }

        function closeModal() {
            modalOverlay.classList.remove('active');
            editingMarkerIndex = null;
            modalRemoveBtn.style.display = 'none';
            modalTitle.textContent = 'Add New Marker';
        }

        // Show category selection dialog
        function showCategorySelection() {
            modalContent.innerHTML = `
                <div class="form-group">
                    <label for="category">Category:</label>
                    <select id="category">
                        <option value="">Select a category</option>
                        ${categoryNames.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                    </select>
                </div>
            `;

            const categorySelect = modalContent.querySelector('#category');
            categorySelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    showTypeSelection(e.target.value);
                }
            });

            openModal();
        }

        // Show type selection for chosen category
        function showTypeSelection(categoryName) {
            // Find the full category object that matches the selected name
            const categoryData = categoriesData.find(cat => cat.name === categoryName);
            
            if (!categoryData || !categoryData.types) {
                console.error('Category data not found for:', categoryName);
                return;
            }
            
            const types = categoryData.types;
            const iconsHtml = types.map(item => `
                <div class="icon-option" data-type="${item.type}" data-icon-type="${item.iconType}">
                    <img src="${item.icon.url}" alt="${item.icon.displayName}">
                    <p>${item.icon.displayName}</p>
                </div>
            `).join('');

            modalContent.innerHTML = `
                <div class="form-group">
                    <label for="category">Category:</label>
                    <input type="text" id="category" value="${categoryName}" readonly>
                </div>
                <div class="form-group">
                    <label>Select Type:</label>
                    <div class="icon-selection">
                        ${iconsHtml}
                    </div>
                </div>
            `;

            const iconOptions = modalContent.querySelectorAll('.icon-option');
            
            iconOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const selectedType = option.dataset.type;
                    const selectedIconType = option.dataset.iconType;
                    showIconSelectionForm(categoryName, selectedType, selectedIconType);
                });
            });
        }

        // Show form with selected icon
        function showIconSelectionForm(category, type, iconType) {
            const selectedIcon = icons[iconType];
            const today = new Date();
            const formattedDate = today.toISOString().split('T')[0];

            modalContent.innerHTML = `
                <div class="icon-selection">
                    <div class="icon-option selected" data-icon="${iconType}">
                        <img src="${selectedIcon.url}" alt="${selectedIcon.displayName}">
                        <p>${selectedIcon.displayName}</p>
                    </div>
                </div>
                <div class="form-group">
                    <label for="category">Category:</label>
                    <input type="text" id="category" value="${category}" readonly>
                </div>
                <div class="form-group">
                    <label for="type">Type:</label>
                    <input type="text" id="type" value="${type}" readonly>
                </div>
                <div class="form-group">
                    <label for="name">Name:</label>
                    <input type="text" id="name" placeholder="Enter a name">
                </div>
                <div class="form-group">
                    <label for="soldQuantity">Sold Quantity:</label>
                    <input type="number" id="soldQuantity" min="0" placeholder="Enter sold quantity">
                </div>
                <div class="form-group">
                    <label for="totalQuantity">Total Quantity:</label>
                    <input type="number" id="totalQuantity" min="0" placeholder="Enter total quantity">
                </div>
                <div class="form-group">
                    <label for="deliveryDate">Delivery Date:</label>
                    <input type="date" id="deliveryDate" value="${formattedDate}">
                </div>
            `;

            const nameInput = modalContent.querySelector('#name');
            const soldQuantityInput = modalContent.querySelector('#soldQuantity');
            const totalQuantityInput = modalContent.querySelector('#totalQuantity');
            const deliveryDateInput = modalContent.querySelector('#deliveryDate');

            function checkFormValidity() {
                const isValid = nameInput.value.trim() !== '' && 
                                soldQuantityInput.value.trim() !== '' && 
                                totalQuantityInput.value.trim() !== '' &&
                                deliveryDateInput.value.trim() !== '';
                modalSaveBtn.disabled = !isValid;
            }

            [nameInput, soldQuantityInput, totalQuantityInput, deliveryDateInput].forEach(input => {
                input.addEventListener('input', checkFormValidity);
            });

            modalSaveBtn.disabled = true;
        }

        // Show edit modal with existing marker data
        function showEditModal(markerData) {
            const iconToShow = icons[markerData.iconType] || Object.values(icons)[0];
            let deliveryDateValue = '';
            if (markerData.deliveryDate) {
                const dateParts = markerData.deliveryDate.split('/');
                if (dateParts.length === 3) {
                    deliveryDateValue = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
                } else {
                    deliveryDateValue = markerData.deliveryDate;
                }
            } else {
                const today = new Date();
                deliveryDateValue = today.toISOString().split('T')[0];
            }

            modalContent.innerHTML = `
                <div class="icon-selection">
                    <div class="icon-option selected" data-icon="${markerData.iconType}">
                        <img src="${iconToShow.url}" alt="${iconToShow.displayName}">
                        <p>${iconToShow.displayName}</p>
                    </div>
                </div>
                <div class="form-group">
                    <label for="category">Category:</label>
                    <input type="text" id="category" value="${markerData.category}" readonly>
                </div>
                <div class="form-group">
                    <label for="type">Type:</label>
                    <input type="text" id="type" value="${markerData.type || ''}" readonly>
                </div>
                <div class="form-group">
                    <label for="name">Name:</label>
                    <input type="text" id="name" value="${markerData.name}">
                </div>
                <div class="form-group">
                    <label for="soldQuantity">Sold Quantity:</label>
                    <input type="number" id="soldQuantity" min="0" value="${markerData.soldQuantity}">
                </div>
                <div class="form-group">
                    <label for="totalQuantity">Total Quantity:</label>
                    <input type="number" id="totalQuantity" min="0" value="${markerData.totalQuantity}">
                </div>
                <div class="form-group">
                    <label for="deliveryDate">Delivery Date:</label>
                    <input type="date" id="deliveryDate" value="${deliveryDateValue}">
                </div>
                <input type="hidden" id="markerId" value="${markerData.id || ''}">
            `;

            const nameInput = modalContent.querySelector('#name');
            const soldQuantityInput = modalContent.querySelector('#soldQuantity');
            const totalQuantityInput = modalContent.querySelector('#totalQuantity');
            const deliveryDateInput = modalContent.querySelector('#deliveryDate');

            function checkFormValidity() {
                const isValid = nameInput.value.trim() !== '' && 
                                soldQuantityInput.value.trim() !== '' && 
                                totalQuantityInput.value.trim() !== '' &&
                                deliveryDateInput.value.trim() !== '';
                modalSaveBtn.disabled = !isValid;
            }

            [nameInput, soldQuantityInput, totalQuantityInput, deliveryDateInput].forEach(input => {
                input.addEventListener('input', checkFormValidity);
            });

            checkFormValidity();
            modalTitle.textContent = 'Edit Marker';
            modalRemoveBtn.style.display = 'inline-block';
            openModal();
        }


// Add a new marker to the map
function addMarker(lngLat, data) {
    // Create container for marker and progress bar
    const container = document.createElement('div');
    container.className = 'marker-container';
    
    // Create icon element
    const el = document.createElement('div');
    el.className = 'marker-btn';
    
    // Add purchased class if status is PURCHASED
    if (data.status && data.status.toUpperCase() === 'PURCHASED') {
        el.classList.add('purchased');
    }

    const icon = icons[data.iconType] || Object.values(icons)[0];
    el.style.backgroundImage = `url(${icon.url})`;
    el.title = icon.displayName;
    
    // Create progress bar
    const progressContainer = document.createElement('div');
    progressContainer.className = 'marker-progress-container';
    
    // Calculate progress
    const soldQuantity = parseInt(data.soldQuantity) || 0;
    const totalQuantity = parseInt(data.totalQuantity) || 0;
    let progress = 0;
    
    // Use exact same logic as in updateProductBar
    if (totalQuantity > 0) {
        // If we have a value from the sheet, use it directly
        if (data.progressBar !== undefined && !isNaN(parseInt(data.progressBar))) {
            progress = parseInt(data.progressBar);
        } else {
            // Otherwise calculate it from quantities
            progress = Math.round((soldQuantity / totalQuantity) * 100);
        }
    }
    
    // Use the same class determination as in updateProductBar
    let progressClass = '';
    if (progress < 30) {
        progressClass = 'low';
    } else if (progress >= 30 && progress < 70) {
        progressClass = 'medium';
    } else {
        progressClass = 'high';
    }
    
    const progressBar = document.createElement('div');
    progressBar.className = `marker-progress-bar ${progressClass}`;
    progressBar.style.width = `${progress}%`;
    
    // Create quantity info element
    const quantityInfo = document.createElement('div');
    quantityInfo.className = 'marker-quantity-info';
    quantityInfo.textContent = `${soldQuantity} / ${totalQuantity}`;
    
    // Add elements to container
    container.appendChild(el);
    
    // ONLY add progress bar and quantity info if status is PURCHASED
    if (data.status && data.status.toUpperCase() === 'PURCHASED') {
        progressContainer.appendChild(progressBar);
        container.appendChild(progressContainer);
        container.appendChild(quantityInfo);
    }

    const percentSold = ((data.soldQuantity / data.totalQuantity) * 100).toFixed(1);

    const popup = new mapboxgl.Popup({ offset: 25 })
        .setHTML(`
            <strong>${data.name} (${icon.displayName})</strong><br>
            Category: ${data.category}<br>
            Sold: ${data.soldQuantity} / ${data.totalQuantity} (${percentSold}%)<br>
            Delivery Time: ${data.deliveryTime} days<br>
            ${data.status ? `Status: ${data.status}<br>` : ''}
            Coordinates: ${lngLat.lat.toFixed(6)}, ${lngLat.lng.toFixed(6)}
        `);

    const marker = new mapboxgl.Marker(container)
        .setLngLat(lngLat)
        .setPopup(popup)
        .addTo(map);

    el.addEventListener('click', (e) => {
        e.stopPropagation();
        const markerIndex = markers.findIndex(m => m.marker === marker);
        if (markerIndex !== -1) {
            editingMarkerIndex = markerIndex;
            currentLatLng = lngLat;
            showEditModal(markers[markerIndex].data);
        }
    });

    markers.push({
        marker: marker,
        data: {
            ...data,
            lngLat: lngLat,
            id: data.id,
            progressBar: progress
        }
    });

    return marker;
}

function updateMarkerPopup(marker, data) {
    const markerElement = marker.getElement();
    const markerBtn = markerElement.querySelector('.marker-btn');
    
    const icon = icons[data.iconType] || Object.values(icons)[0];
    
    // First, check if status changed
    const wasPurchased = markerBtn.classList.contains('purchased');
    const isPurchased = data.status && data.status.toUpperCase() === 'PURCHASED';
    
    // Update purchased class based on status
    if (isPurchased) {
        markerBtn.classList.add('purchased');
    } else {
        markerBtn.classList.remove('purchased');
    }
    
    markerBtn.style.backgroundImage = `url(${icon.url})`;
    markerBtn.title = icon.displayName;

    // Calculate progress values regardless (we'll need them for the popup and potentially for display)
    const soldQuantity = parseInt(data.soldQuantity) || 0;
    const totalQuantity = parseInt(data.totalQuantity) || 0;
    let progress = 0;
    
    if (totalQuantity > 0) {
        progress = Math.round((soldQuantity / totalQuantity) * 100);
    }
    
    // If status changed from not purchased to purchased, we need to add the progress elements
    if (isPurchased && !wasPurchased) {
        // Create new progress elements
        const progressContainer = document.createElement('div');
        progressContainer.className = 'marker-progress-container';
        
        const progressBar = document.createElement('div');
        progressBar.className = 'marker-progress-bar';
        if (progress >= 70) {
            progressBar.classList.add('high');
        } else if (progress >= 30) {
            progressBar.classList.add('medium');
        } else {
            progressBar.classList.add('low');
        }
        progressBar.style.width = `${progress}%`;
        
        progressContainer.appendChild(progressBar);
        
        const quantityInfo = document.createElement('div');
        quantityInfo.className = 'marker-quantity-info';
        quantityInfo.textContent = `${soldQuantity} / ${totalQuantity}`;
        
        // Add new elements
        markerElement.appendChild(progressContainer);
        markerElement.appendChild(quantityInfo);
    } 
    // If status changed from purchased to not purchased, remove the progress elements
    else if (!isPurchased && wasPurchased) {
        const progressContainer = markerElement.querySelector('.marker-progress-container');
        const quantityInfo = markerElement.querySelector('.marker-quantity-info');
        
        if (progressContainer) markerElement.removeChild(progressContainer);
        if (quantityInfo) markerElement.removeChild(quantityInfo);
    }
    // If it was already purchased and remains purchased, update the progress values
    else if (isPurchased) {
        const progressBar = markerElement.querySelector('.marker-progress-bar');
        const quantityInfo = markerElement.querySelector('.marker-quantity-info');
        
        if (progressBar) {
            // Update progress bar class
            progressBar.classList.remove('low', 'medium', 'high');
            if (progress >= 70) {
                progressBar.classList.add('high');
            } else if (progress >= 30) {
                progressBar.classList.add('medium');
            } else {
                progressBar.classList.add('low');
            }
            
            progressBar.style.width = `${progress}%`;
        }
        
        if (quantityInfo) {
            quantityInfo.textContent = `${soldQuantity} / ${totalQuantity}`;
        }
    }

    const percentSold = ((data.soldQuantity / data.totalQuantity) * 100).toFixed(1);
    const coordinates = `${marker.getLngLat().lat.toFixed(6)},${marker.getLngLat().lng.toFixed(6)}`;

    marker.getPopup().setHTML(`
        <strong>${data.name} (${icon.displayName})</strong><br>
        Category: ${data.category}<br>
        ${data.type ? `Type: ${data.type}<br>` : ''}
        Sold: ${data.soldQuantity} / ${data.totalQuantity} (${percentSold}%)<br>
        ${data.deliveryDate ? `Delivery Date: ${data.deliveryDate}<br>` : ''}
        ${data.status ? `Status: ${data.status}<br>` : ''}
        Coordinates: ${coordinates}
    `);
}

        // Delete marker from Google Sheet
        function deleteMarkerFromSheet(markerId) {
            if (!sheetId) {
                showStatus('No Google Sheet ID found.', true);
                return Promise.resolve(false);
            }

            try {
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbzxxZHuA9Bmc_vCcIk0vX_UVZb_iKDC_8K-leCpUEg-adzxexb6FwvaWhmjLcvu3hyi6w/exec';
                const dataToDelete = {
                    ID: markerId
                };

                console.log('Sending delete request:', dataToDelete);
                const callbackName = 'googleSheetCallback_' + Date.now();
                const params = new URLSearchParams({ 
                    action: 'delete', 
                    data: JSON.stringify(dataToDelete) 
                });
                const fullUrl = `${scriptUrl}?${params.toString()}&callback=${callbackName}`;

                showStatus('Deleting marker...');

                return new Promise(resolve => {
                    window[callbackName] = response => {
                        console.log("Delete response:", response);
                        document.body.removeChild(script);
                        delete window[callbackName];
                        clearTimeout(timeoutId);
                        
                        if (response?.status === 'success') {
                            showStatus('Marker deleted successfully!');
                            resolve(true);
                        } else {
                            showStatus(`Failed to delete: ${response?.message || 'No response'}`, true);
                            resolve(false);
                        }
                    };

                    const script = document.createElement('script');
                    script.src = fullUrl;
                    script.onerror = () => {
                        console.error("Script load error during delete");
                        clearTimeout(timeoutId);
                        document.body.removeChild(script);
                        delete window[callbackName];
                        showStatus('Failed to connect to script during delete.', true);
                        resolve(false);
                    };

                    const timeoutId = setTimeout(() => {
                        document.body.removeChild(script);
                        delete window[callbackName];
                        showStatus('Delete request timed out.', true);
                        resolve(false);
                    }, 15000);

                    document.body.appendChild(script);
                });
            } catch (error) {
                console.error('Error deleting marker:', error);
                showStatus(`Failed to delete: ${error.message}`, true);
                return Promise.resolve(false);
            }
        }

        // Update product bar after deletion
        function updateProductBarAfterDeletion() {
            // Recalculate unique products based on remaining markers
            uniqueProducts = {};
            
            markers.forEach(marker => {
                const { name, category, type, iconType, soldQuantity, totalQuantity, progressBar } = marker.data;
                const productKey = name ? name : `${category}-${type}`;
                
                if (!uniqueProducts[productKey] || progressBar > uniqueProducts[productKey].progress) {
                    uniqueProducts[productKey] = {
                        name: name || type || category,
                        iconType: iconType,
                        progress: progressBar || 0,
                        category: category,
                        type: type,
                        soldQuantity: soldQuantity,
                        totalQuantity: totalQuantity
                    };
                }
            });
            
            // Update the product bar with the recalculated products
            updateProductBar();
        }

        // Save marker to Google Sheet
        function saveMarkerToSheet(markerData, action = 'add') {
            if (!sheetId) {
                showStatus('No Google Sheet ID found.', true);
                return Promise.resolve(false);
            }

            try {
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbzxxZHuA9Bmc_vCcIk0vX_UVZb_iKDC_8K-leCpUEg-adzxexb6FwvaWhmjLcvu3hyi6w/exec';
                let dataToSave = action === 'update' ? {
                    ID: markerData.id,
                    NAME: markerData.name,
                    'SOLD QUANTITY': markerData.soldQuantity,
                    'TOTAL QUANTITY': markerData.totalQuantity,
                    'Delivery Date': markerData.deliveryDate
                } : {
                    ID: markerData.id || Date.now().toString(),
                    CATEGORY: markerData.category,
                    TYPE: markerData.type,
                    NAME: markerData.name,
                    COORDINATES: `${markerData.lngLat.lat.toFixed(6)},${markerData.lngLat.lng.toFixed(6)}`,
                    'Delivery Date': markerData.deliveryDate,
                    'SOLD QUANTITY': markerData.soldQuantity,
                    'TOTAL QUANTITY': markerData.totalQuantity,
                    'STATUS': markerData.status || 'AVAILABLE',
                    'PROGRESS BAR': markerData.progressBar || 0
                };

                console.log(`Sending ${action} data:`, dataToSave);
                const callbackName = 'googleSheetCallback_' + Date.now();
                const params = new URLSearchParams({ action, data: JSON.stringify(dataToSave) });
                const fullUrl = `${scriptUrl}?${params.toString()}&callback=${callbackName}`;
                console.log("Full request URL:", fullUrl);

                showStatus(`${action === 'update' ? 'Updating' : 'Saving'} marker...`);

                return new Promise(resolve => {
                    window[callbackName] = response => {
                        console.log("Raw response:", response);
                        document.body.removeChild(script);
                        delete window[callbackName];
                        clearTimeout(timeoutId);
                        if (response?.status === 'success') {
                            showStatus(`Marker ${action === 'update' ? 'updated' : 'added'} successfully!`);
                            resolve(true);
                        } else {
                            showStatus(`Failed to ${action}: ${response?.message || 'No response'}`, true);
                            resolve(false);
                        }
                    };

                    const script = document.createElement('script');
                    script.src = fullUrl;
                    script.onerror = () => {
                        console.error("Script load error");
                        clearTimeout(timeoutId);
                        document.body.removeChild(script);
                        delete window[callbackName];
                        showStatus('Failed to connect to script.', true);
                        resolve(false);
                    };

                    const timeoutId = setTimeout(() => {
                        document.body.removeChild(script);
                        delete window[callbackName];
                        showStatus('Request timed out.', true);
                        resolve(false);
                    }, 15000);

                    document.body.appendChild(script);
                });
            } catch (error) {
                console.error(`Error ${action}ing:`, error);
                showStatus(`Failed to ${action}: ${error.message}`, true);
                return Promise.resolve(false);
            }
        }

        // Fetch Google Sheet data
        async function fetchGoogleSheetData(url) {
            try {
                let id = url;
                if (url.includes('docs.google.com/spreadsheets')) {
                    const match = url.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
                    if (match && match[1]) {
                        id = match[1];
                    }
                }

                const vizUrl = `https://docs.google.com/spreadsheets/d/${id}/gviz/tq`;
                try {
                    const response = await fetch(vizUrl);
                    if (!response.ok) throw new Error('Visualization API failed');
                    const text = await response.text();
                    const jsonStart = text.indexOf('{');
                    const jsonEnd = text.lastIndexOf('}') + 1;
                    if (jsonStart > 0 && jsonEnd > 0) {
                        const jsonStr = text.substring(jsonStart, jsonEnd);
                        const data = JSON.parse(jsonStr);
                        return processVisualizationApiData(data);
                    } else throw new Error('Invalid JSON format');
                } catch (vizError) {
                    const csvUrl = `https://docs.google.com/spreadsheets/d/${id}/export?format=csv`;
                    const response = await fetch(csvUrl);
                    if (!response.ok) throw new Error(`Failed to fetch sheet data: ${response.status}`);
                    const csvText = await response.text();
                    return parseCSV(csvText);
                }
            } catch (error) {
                console.error('Error in fetchGoogleSheetData:', error);
                throw error;
            }
        }

        // Process data from Google Sheets Visualization API
        function processVisualizationApiData(data) {
            if (!data.table || !data.table.cols || !data.table.rows) throw new Error('Invalid visualization API data format');
            const cols = data.table.cols;
            const columnMap = {};
            cols.forEach((col, index) => {
                if (col.label) columnMap[col.label.trim()] = index;
            });
            return data.table.rows.map(row => {
                const result = {};
                if ('ID' in columnMap && row.c[columnMap['ID']]) result['ID'] = row.c[columnMap['ID']].v.toString();
                if ('CATEGORY' in columnMap && row.c[columnMap['CATEGORY']]) result['CATEGORY'] = row.c[columnMap['CATEGORY']].v;
                if ('TYPE' in columnMap && row.c[columnMap['TYPE']]) result['TYPE'] = row.c[columnMap['TYPE']].v;
                if ('NAME' in columnMap && row.c[columnMap['NAME']]) result['NAME'] = row.c[columnMap['NAME']].v;
                if ('COORDINATES' in columnMap && row.c[columnMap['COORDINATES']]) result['COORDINATES'] = row.c[columnMap['COORDINATES']].v;
                if ('Delivery Date' in columnMap && row.c[columnMap['Delivery Date']]) {
                    if (row.c[columnMap['Delivery Date']].f) result['Delivery Date'] = row.c[columnMap['Delivery Date']].f;
                    else if (row.c[columnMap['Delivery Date']].v) {
                        const dateStr = row.c[columnMap['Delivery Date']].v;
                        if (dateStr.startsWith('Date(')) {
                            const dateParams = dateStr.replace('Date(', '').replace(')', '').split(',');
                            const year = parseInt(dateParams[0]);
                            const month = parseInt(dateParams[1]);
                            const day = parseInt(dateParams[2]);
                            const date = new Date(year, month, day);
                            result['Delivery Date'] = `${day.toString().padStart(2, '0')}/${(month + 1).toString().padStart(2, '0')}/${year}`;
                        }
                    }
                }
                if ('SOLD QUANTITY' in columnMap && row.c[columnMap['SOLD QUANTITY']]) result['SOLD QUANTITY'] = row.c[columnMap['SOLD QUANTITY']].v;
                if ('TOTAL QUANTITY' in columnMap && row.c[columnMap['TOTAL QUANTITY']]) result['TOTAL QUANTITY'] = row.c[columnMap['TOTAL QUANTITY']].v;
                if ('STATUS' in columnMap && row.c[columnMap['STATUS']]) result['STATUS'] = row.c[columnMap['STATUS']].v;
                if ('PROGRESS BAR' in columnMap && row.c[columnMap['PROGRESS BAR']]) result['PROGRESS BAR'] = row.c[columnMap['PROGRESS BAR']].v;
                return result;
            });
        }

        // Parse CSV data
        function parseCSV(csvText) {
            return new Promise((resolve, reject) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => resolve(results.data),
                    error: (error) => reject(error)
                });
            });
        }

        // Process sheet data to create markers
        function processSheetData(data) {
            clearExistingMarkers();
            if (!data || data.length === 0) {
                showStatus('No valid data found in the sheet.', true);
                return;
            }
            
            // Reset unique products
            uniqueProducts = {};
            
            let markersAdded = 0;
            data.forEach(row => {
                let lat, lng;
                
                if (row['COORDINATES']) {
                    const coordParts = row['COORDINATES'].toString().split(',');
                    if (coordParts.length === 2) {
                        lat = parseFloat(coordParts[0].trim());
                        lng = parseFloat(coordParts[1].trim());
                    } else return;
                } else return;
                
                if (isNaN(lat) || isNaN(lng)) return;
                
                const category = (row['CATEGORY'] || '').toString().trim();
                const type = (row['TYPE'] || '').toString().trim();
                const name = (row['NAME'] || '').toString().trim();
                
                // Find the matching category in categoriesData
                let iconType = null;
                
                // Search through all categories and types to find a match
                const matchedCategory = categoriesData.find(cat => 
                    cat.name.toUpperCase() === category.toUpperCase());
                    
                if (matchedCategory) {
                    // If category matches, try to match the type
                    const matchedType = matchedCategory.types.find(t => 
                        t.type.toUpperCase() === type.toUpperCase());
                        
                    if (matchedType) {
                        iconType = matchedType.iconType;
                    } else if (matchedCategory.types.length > 0) {
                        // If no exact type match, use the first type in the category
                        iconType = matchedCategory.types[0].iconType;
                    }
                }
                
                // If we still don't have an iconType, use a default
                if (!iconType) {
                    iconType = 'apple_green'; // Default fallback
                    console.log(`No icon match found for: ${category} - ${type}, using default`);
                }
                
                const soldQuantity = parseInt(row['SOLD QUANTITY'] || 0);
                const totalQuantity = parseInt(row['TOTAL QUANTITY'] || 0);
                const deliveryDate = row['Delivery Date'] || '';
                
                // Get progress bar value from sheet
                const progressBarValue = parseInt(row['PROGRESS BAR'] || 0);
                
                let deliveryTime = 0;
                if (deliveryDate) {
                    const dateStr = deliveryDate.toString();
                    let deliveryDateObj;
                    
                    if (dateStr.includes('/')) {
                        const parts = dateStr.split('/');
                        if (parts.length === 3) 
                            deliveryDateObj = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
                    } else 
                        deliveryDateObj = new Date(dateStr);
                        
                    if (!isNaN(deliveryDateObj.getTime())) {
                        const currentDate = new Date();
                        const diffTime = Math.abs(deliveryDateObj - currentDate);
                        deliveryTime = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    }
                }
                
                const markerData = {
                    id: row['ID'],
                    iconType: iconType,
                    category: category,
                    type: type,
                    name: name || row['ID'] || 'Unknown',
                    soldQuantity: soldQuantity,
                    totalQuantity: totalQuantity,
                    deliveryDate: deliveryDate,
                    deliveryTime: deliveryTime,
                    status: row['STATUS'] || '',
                    progressBar: progressBarValue
                };
                
                // Use the name as the unique identifier if available
                const productKey = name ? name : `${category}-${type}`;
                
                // If this product doesn't exist in our collection yet, or if we want to update it
                if (!uniqueProducts[productKey] || progressBarValue > uniqueProducts[productKey].progress) {
                    uniqueProducts[productKey] = {
                        name: name || type || category,
                        iconType: iconType,
                        progress: progressBarValue,
                        category: category,
                        type: type,
                        soldQuantity: soldQuantity,
                        totalQuantity: totalQuantity
                    };
                }
                
                addMarker(new mapboxgl.LngLat(lng, lat), markerData);
                markersAdded++;
            });
            
            // Update product bar after processing all data
            updateProductBar();
            
            if (markersAdded === 0) 
                showStatus('No valid markers could be created from the sheet data.', true);
            else {
                showStatus(`Successfully loaded ${markersAdded} markers from Google Sheet.`);
                zoomToFitMarkers();
            }
        }

        // Update product bar with available products
        function updateProductBar() {
            productBar.innerHTML = '';
            
            // Get all product items
            const productItems = Object.values(uniqueProducts);
            
            // If no products, keep product bar hidden
            if (productItems.length === 0) {
                productBar.style.display = 'none';
                return;
            }
            
            // Sort products by name
            productItems.sort((a, b) => a.name.localeCompare(b.name));
            
            // Create product items for each unique product
            productItems.forEach(product => {
                const productItem = document.createElement('div');
                productItem.className = 'product-item';
                
                // Get icon for the product
                const icon = icons[product.iconType] || Object.values(icons)[0];
                
                // Make sure progress is a number
                const progress = parseInt(product.progress || 0);
                
                // Calculate progress class based on value
                let progressClass = '';
                if (progress < 30) {
                    progressClass = 'low';
                } else if (progress >= 30 && progress < 70) {
                    progressClass = 'medium';
                } else {
                    progressClass = 'high';
                }
                
                // Use the product name from the sheet
                const displayName = product.name;
                
                // Get the sold and total quantities
                const soldQuantity = product.soldQuantity || 0;
                const totalQuantity = product.totalQuantity || 0;
                
                productItem.innerHTML = `
                    <img src="${icon.url}" alt="${displayName}" class="product-icon">
                    <div class="product-name">${displayName}</div>
                    <div class="progress-container">
                        <div class="progress-bar ${progressClass}" style="width: ${progress}%"></div>
                        <div class="progress-value">${progress}%</div>
                    </div>
                    <div class="quantity-info">${soldQuantity} / ${totalQuantity}</div>
                `;
                
                productBar.appendChild(productItem);
            });
            
            // Show product bar after it's populated
            productBar.style.display = 'flex';
        }

        // Zoom map to fit all markers
        function zoomToFitMarkers() {
            if (markers.length === 0) return;
            
            const bounds = new mapboxgl.LngLatBounds();
            markers.forEach(marker => bounds.extend(marker.marker.getLngLat()));
            
            map.fitBounds(bounds, {
                padding: 100,  // Increased padding around markers
                maxZoom: 6    // Reduced maximum zoom level
            });
        }

        // Clear all existing markers from the map
        function clearExistingMarkers() {
            markers.forEach(marker => marker.marker.remove());
            markers.length = 0;
        }

// Auto-reload data from Google Sheet every 30 seconds
let autoReloadInterval;

function startAutoReload() {
    // Clear any existing interval first
    if (autoReloadInterval) {
        clearInterval(autoReloadInterval);
    }
    
    // Set up new interval to reload data every 30 seconds
    autoReloadInterval = setInterval(() => {
        console.log("Auto-reloading data from Google Sheet...");
        loadDataFromSavedId(true); // Pass true to indicate this is an auto-reload
    }, 30000); // 30000 ms = 30 seconds
    
    console.log("Auto-reload started: Data will refresh every 30 seconds");
}

function stopAutoReload() {
    if (autoReloadInterval) {
        clearInterval(autoReloadInterval);
        autoReloadInterval = null;
        console.log("Auto-reload stopped");
    }
}

// Load Data From SavedId with auto-reload
async function loadDataFromSavedId(isAutoReload = false) {
    try {
        // Only show loading indicator and disable button if not an auto-reload
        if (!isAutoReload) {
            loadingContainer.style.display = 'flex';
            productBar.style.display = 'none';
            loadDataBtn.disabled = true;
            loadDataBtn.textContent = 'Loading...';
        }
        
        const data = await fetchGoogleSheetData(sheetId);
        if (!data || data.length === 0) {
            if (!isAutoReload) {
                showStatus('No data found in the sheet.', true);
            }
        } else {
            processSheetData(data);
            if (!isAutoReload) {
                showStatus(`Successfully loaded ${markers.length} markers from Google Sheet.`);
            } else {
                console.log(`Auto-reload: Updated ${markers.length} markers from Google Sheet`);
            }
        }
    } catch (error) {
        if (!isAutoReload) {
            showStatus('Failed to load data: ' + error.message, true);
        } else {
            console.error('Auto-reload failed:', error.message);
        }
    } finally {
        // Only update UI elements if not an auto-reload
        if (!isAutoReload) {
            loadingContainer.style.display = 'none';
            loadDataBtn.disabled = false;
            loadDataBtn.textContent = 'Refresh Data';
        }
    }
}

        
        // Map click event handler
        map.on('click', (e) => {
            if (!e.originalEvent.target.classList.contains('marker-btn')) {
                currentLatLng = e.lngLat;
                showCategorySelection();
            }
        });

        // Modal cancel button click handler
        modalCancelBtn.addEventListener('click', () => {
            closeModal();
        });

        // Modal remove button click handler
        modalRemoveBtn.addEventListener('click', () => {
            if (editingMarkerIndex !== null) {
                const marker = markers[editingMarkerIndex];
                const markerId = marker.data.id;
                
                if (markerId) {
                    // Show confirmation dialog
                    if (confirm('Are you sure you want to delete this marker? This action cannot be undone.')) {
                        // Delete from Google Sheet first
                        deleteMarkerFromSheet(markerId).then(success => {
                            if (success) {
                                // If successful, remove from map
                                marker.marker.remove();
                                markers.splice(editingMarkerIndex, 1);
                                showStatus('Marker deleted successfully!');
                                
                                // Update product bar after deletion
                                updateProductBarAfterDeletion();
                                closeModal();
                            } else {
                                showStatus('Failed to delete marker from sheet, but keeping it on the map.', true);
                            }
                        });
                    }
                } else {
                    // If no ID exists (new marker that wasn't saved), just remove from map
                    marker.marker.remove();
                    markers.splice(editingMarkerIndex, 1);
                    closeModal();
                }
            }
        });

        // Modal save button click handler
        modalSaveBtn.addEventListener('click', () => {
            const iconElement = modalContent.querySelector('.icon-option.selected');
            const selectedIconType = iconElement ? iconElement.dataset.icon : Object.keys(icons)[0];
            const category = modalContent.querySelector('#category').value;
            const type = modalContent.querySelector('#type').value || '';
            const name = modalContent.querySelector('#name').value;
            const soldQuantity = parseInt(modalContent.querySelector('#soldQuantity').value, 10);
            const totalQuantity = parseInt(modalContent.querySelector('#totalQuantity').value, 10);
            const deliveryDateInput = modalContent.querySelector('#deliveryDate');
            let deliveryDate = '';

            const idElement = modalContent.querySelector('#markerId');
            const id = idElement ? idElement.value : null;

            if (deliveryDateInput && deliveryDateInput.value) {
                const dateObj = new Date(deliveryDateInput.value);
                const day = dateObj.getDate().toString().padStart(2, '0');
                const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
                const year = dateObj.getFullYear();
                deliveryDate = `${day}/${month}/${year}`;
            }

            const markerData = {
                id: id,
                iconType: selectedIconType,
                category: category,
                type: type,
                name: name,
                soldQuantity: soldQuantity,
                totalQuantity: totalQuantity,
                deliveryDate: deliveryDate,
                deliveryTime: calculatedDeliveryTime(),
                status: 'AVAILABLE'
            };

            function calculatedDeliveryTime() {
                if (!deliveryDateInput || !deliveryDateInput.value) return 0;
                const selectedDate = new Date(deliveryDateInput.value);
                const currentDate = new Date();
                const diffTime = Math.abs(selectedDate - currentDate);
                return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            }

            if (editingMarkerIndex !== null) {
                const existingMarker = markers[editingMarkerIndex];
                markerData.lngLat = existingMarker.data.lngLat;

                if (!markerData.id && existingMarker.data.id) {
                    markerData.id = existingMarker.data.id;
                }

                if (existingMarker.data.status) {
                    markerData.status = existingMarker.data.status;
                }

                existingMarker.data = { ...markerData };
                updateMarkerPopup(existingMarker.marker, markerData);

                saveMarkerToSheet(markerData, 'update').then(success => {
                    if (success) {
                        console.log('Marker updated in Google Sheet successfully');
                    }
                });
            } else {
                markerData.lngLat = currentLatLng;
                const newMarker = addMarker(currentLatLng, markerData);

                saveMarkerToSheet(markerData, 'add').then(success => {
                    if (success) {
                        console.log('Marker saved to Google Sheet successfully');
                    }
                });
            }

            closeModal();
        });

        // Load data button click handler
        loadDataBtn.addEventListener('click', () => {
            loadDataFromSavedId();
        });

        // Map load event handler
        map.on('load', () => {
    updateCurrentSheetIdDisplay();
    
    // Show loading indicator at start
    loadingContainer.style.display = 'flex';
    // Make sure product bar is hidden initially
    productBar.style.display = 'none';
    
    if (sheetId) {
        // Initial data load
        setTimeout(() => {
            loadDataFromSavedId().then(() => {
                // Start auto-reload after initial data load
                startAutoReload();
            });
        }, 2000);
    } else {
        // Hide loading if no sheet ID
        loadingContainer.style.display = 'none';
    }
});
    </script>
</body>
</html>